/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * <p>
 * Code generated by Microsoft (R) AutoRest Code Generator 1.2.2.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

/**
 * Code generated by Microsoft (R) AutoRest Code Generator 1.2.2.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.azure.dfs.client.generated.implementation;

import java.io.IOException;
import java.io.InputStream;

import com.google.gson.reflect.TypeToken;
import com.microsoft.azure.dfs.client.generated.AzureDistributedFileSystemClient;
import com.microsoft.azure.dfs.client.generated.models.ContentType;
import com.microsoft.azure.dfs.client.generated.models.CreateFilesystemHeaders;
import com.microsoft.azure.dfs.client.generated.models.CreatePathHeaders;
import com.microsoft.azure.dfs.client.generated.models.DeleteFilesystemHeaders;
import com.microsoft.azure.dfs.client.generated.models.DeletePathHeaders;
import com.microsoft.azure.dfs.client.generated.models.ErrorSchemaException;
import com.microsoft.azure.dfs.client.generated.models.GetFilesystemPropertiesHeaders;
import com.microsoft.azure.dfs.client.generated.models.GetPathPropertiesHeaders;
import com.microsoft.azure.dfs.client.generated.models.LeasePathHeaders;
import com.microsoft.azure.dfs.client.generated.models.ListPathsHeaders;
import com.microsoft.azure.dfs.client.generated.models.ListSchema;
import com.microsoft.azure.dfs.client.generated.models.ReadPathHeaders;
import com.microsoft.azure.dfs.client.generated.models.SetFilesystemPropertiesHeaders;
import com.microsoft.azure.dfs.client.generated.models.UpdatePathHeaders;
import com.microsoft.rest.RestClient;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponseWithHeaders;
import okhttp3.OkHttpClient;
import okhttp3.ResponseBody;
import org.joda.time.DateTime;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.http.GET;
import retrofit2.http.HEAD;
import retrofit2.http.HTTP;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.PATCH;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Path;
import retrofit2.http.Query;
import retrofit2.http.Streaming;
import rx.Observable;
import rx.functions.Func1;

/**
 * Initializes a new instance of the AzureDistributedFileSystemClient class.
 */
public class AzureDistributedFileSystemClientImpl extends ServiceClient implements AzureDistributedFileSystemClient {
  /**
   * The Retrofit service to perform REST calls.
   */
  private AzureDistributedFileSystemClientService service;

  /** Specifies the authentication scheme, account name, and signature. This is required when using shared key authorization. */
  private String authorization;

  /**
   * Gets Specifies the authentication scheme, account name, and signature. This is required when using shared key authorization.
   *
   * @return the authorization value.
   */
  public String authorization() {
    return this.authorization;
  }

  /**
   * Sets Specifies the authentication scheme, account name, and signature. This is required when using shared key authorization.
   *
   * @param authorization the authorization value.
   * @return the service client itself
   */
  public AzureDistributedFileSystemClientImpl withAuthorization(String authorization) {
    this.authorization = authorization;
    return this;
  }

  /** Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization. */
  private DateTime dateProperty;

  /**
   * Gets Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
   *
   * @return the dateProperty value.
   */
  public DateTime dateProperty() {
    return this.dateProperty;
  }

  /**
   * Sets Specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
   *
   * @param dateProperty the dateProperty value.
   * @return the service client itself
   */
  public AzureDistributedFileSystemClientImpl withDateProperty(DateTime dateProperty) {
    this.dateProperty = dateProperty;
    return this;
  }

  /** An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before the
   * operation completes, the operation fails. */
  private int timeout;

  /**
   * Gets An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before
   * the operation completes, the operation fails.
   *
   * @return the timeout value.
   */
  public int timeout() {
    return this.timeout;
  }

  /**
   * Sets An optional operation timeout value in seconds. The period begins when the request is received by the service. If the timeout value elapses before
   * the operation completes, the operation fails.
   *
   * @param timeout the timeout value.
   * @return the service client itself
   */
  public AzureDistributedFileSystemClientImpl withTimeout(int timeout) {
    this.timeout = timeout;
    return this;
  }

  /** Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization. */
  private DateTime xMsVersion;

  /**
   * Gets Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
   *
   * @return the xMsVersion value.
   */
  public DateTime xMsVersion() {
    return this.xMsVersion;
  }

  /**
   * Sets Specifies the version of the REST protocol used for processing the request. This is required when using shared key authorization.
   *
   * @param xMsVersion the xMsVersion value.
   * @return the service client itself
   */
  public AzureDistributedFileSystemClientImpl withXMsVersion(DateTime xMsVersion) {
    this.xMsVersion = xMsVersion;
    return this;
  }

  /** A comma-separated list of properties n1=v1,n2=v2,... to be associated with the resource. */
  private String xMsProperties;

  /**
   * Gets A comma-separated list of properties n1=v1,n2=v2,... to be associated with the resource.
   *
   * @return the xMsProperties value.
   */
  public String xMsProperties() {
    return this.xMsProperties;
  }

  /**
   * Sets A comma-separated list of properties n1=v1,n2=v2,... to be associated with the resource.
   *
   * @param xMsProperties the xMsProperties value.
   * @return the service client itself
   */
  public AzureDistributedFileSystemClientImpl withXMsProperties(String xMsProperties) {
    this.xMsProperties = xMsProperties;
    return this;
  }

  /** Optional.  Valid only when using the "Set Properties" operations or the "Flush Data" operation for files.  A comma-separated list of properties (n1=v1,
   * n2=v2,...) to be associated with the resource.  If the resource exists, any properties not included in the list will be removed.  All properties are
   * removed if the header is omitted.  To merge new and existing properties, first get all existing properties and the current E-Tag, then make a conditional
   * request with the E-Tag and include values for all properties. */
  private String xMsProperties1;

  /**
   * Gets Optional.  Valid only when using the "Set Properties" operations or the "Flush Data" operation for files.  A comma-separated list of properties
   * (n1=v1,n2=v2,...) to be associated with the resource.  If the resource exists, any properties not included in the list will be removed.  All properties
   * are removed if the header is omitted.  To merge new and existing properties, first get all existing properties and the current E-Tag, then make a
   * conditional request with the E-Tag and include values for all properties.
   *
   * @return the xMsProperties1 value.
   */
  public String xMsProperties1() {
    return this.xMsProperties1;
  }

  /**
   * Sets Optional.  Valid only when using the "Set Properties" operations or the "Flush Data" operation for files.  A comma-separated list of properties
   * (n1=v1,n2=v2,...) to be associated with the resource.  If the resource exists, any properties not included in the list will be removed.  All properties
   * are removed if the header is omitted.  To merge new and existing properties, first get all existing properties and the current E-Tag, then make a
   * conditional request with the E-Tag and include values for all properties.
   *
   * @param xMsProperties1 the xMsProperties1 value.
   * @return the service client itself
   */
  public AzureDistributedFileSystemClientImpl withXMsProperties1(String xMsProperties1) {
    this.xMsProperties1 = xMsProperties1;
    return this;
  }

  /** A UUID recorded in the analytics logs for troubleshooting and correlation. */
  private String xMsClientRequestId;

  /**
   * Gets A UUID recorded in the analytics logs for troubleshooting and correlation.
   *
   * @return the xMsClientRequestId value.
   */
  public String xMsClientRequestId() {
    return this.xMsClientRequestId;
  }

  /**
   * Sets A UUID recorded in the analytics logs for troubleshooting and correlation.
   *
   * @param xMsClientRequestId the xMsClientRequestId value.
   * @return the service client itself
   */
  public AzureDistributedFileSystemClientImpl withXMsClientRequestId(String xMsClientRequestId) {
    this.xMsClientRequestId = xMsClientRequestId;
    return this;
  }

  /** A UUID persisted with the resource upon creation and used to identify the request that created it. */
  private String xMsOriginationId;

  /**
   * Gets A UUID persisted with the resource upon creation and used to identify the request that created it.
   *
   * @return the xMsOriginationId value.
   */
  public String xMsOriginationId() {
    return this.xMsOriginationId;
  }

  /**
   * Sets A UUID persisted with the resource upon creation and used to identify the request that created it.
   *
   * @param xMsOriginationId the xMsOriginationId value.
   * @return the service client itself
   */
  public AzureDistributedFileSystemClientImpl withXMsOriginationId(String xMsOriginationId) {
    this.xMsOriginationId = xMsOriginationId;
    return this;
  }

  /** Specifies the version of the REST protocol to be used for processing the request. */
  private DateTime apiVersion;

  /**
   * Gets Specifies the version of the REST protocol to be used for processing the request.
   *
   * @return the apiVersion value.
   */
  public DateTime apiVersion() {
    return this.apiVersion;
  }

  /**
   * Sets Specifies the version of the REST protocol to be used for processing the request.
   *
   * @param apiVersion the apiVersion value.
   * @return the service client itself
   */
  public AzureDistributedFileSystemClientImpl withApiVersion(DateTime apiVersion) {
    this.apiVersion = apiVersion;
    return this;
  }

  /**
   * Initializes an instance of AzureDistributedFileSystemClient client.
   */
  public AzureDistributedFileSystemClientImpl() {
    this("http://account.data.core.windows.net");
  }

  /**
   * Initializes an instance of AzureDistributedFileSystemClient client.
   *
   * @param baseUrl the base URL of the host
   */
  public AzureDistributedFileSystemClientImpl(String baseUrl) {
    super(baseUrl);
    initialize();
  }

  /**
   * Initializes an instance of AzureDistributedFileSystemClient client.
   *
   * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
   * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
   */
  public AzureDistributedFileSystemClientImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
    this("http://account.data.core.windows.net", clientBuilder, restBuilder);
    initialize();
  }

  /**
   * Initializes an instance of AzureDistributedFileSystemClient client.
   *
   * @param baseUrl the base URL of the host
   * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
   * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
   */
  public AzureDistributedFileSystemClientImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
    super(baseUrl, clientBuilder, restBuilder);
    initialize();
  }

  /**
   * Initializes an instance of AzureDistributedFileSystemClient client.
   *
   * @param restClient the REST client containing pre-configured settings
   */
  public AzureDistributedFileSystemClientImpl(RestClient restClient) {
    super(restClient);
    initialize();
  }

  private void initialize() {
    initializeService();
  }

  private void initializeService() {
    service = retrofit().create(AzureDistributedFileSystemClientService.class);
  }

  /**
   * The interface defining all the services for AzureDistributedFileSystemClient to be
   * used by Retrofit to perform actually REST calls.
   */
  interface AzureDistributedFileSystemClientService {
    @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.dfs.client.AzureDistributedFileSystemClient "
        + "createFilesystem"})
    @PUT("{filesystem}")
    Observable<Response<ResponseBody>> createFilesystem(@Path("filesystem") String filesystem, @Header("x-ms-properties") String xMsProperties, @Header
        ("x-ms-origination-id") String xMsOriginationId, @Query("resource") String resource, @Query("timeout") Integer timeout, @Header("Authorization")
        String authorization, @Header("Date") DateTime dateProperty, @Header("x-ms-version") DateTime xMsVersion, @Header("x-ms-client-request-id") String
        xMsClientRequestId);

    @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.dfs.client.AzureDistributedFileSystemClient "
        + "setFilesystemProperties"})
    @PATCH("{filesystem}")
    Observable<Response<ResponseBody>> setFilesystemProperties(@Path("filesystem") String filesystem, @Query("component") String component, @Header
        ("x-ms-properties") String xMsProperties, @Query("resource") String resource, @Query("timeout") Integer timeout, @Header("Authorization") String
        authorization, @Header("Date") DateTime dateProperty, @Header("x-ms-version") DateTime xMsVersion, @Header("x-ms-client-request-id") String
        xMsClientRequestId);

    @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.dfs.client.AzureDistributedFileSystemClient "
        + "listPaths"})
    @GET("{filesystem}")
    Observable<Response<ResponseBody>> listPaths(@Path("filesystem") String filesystem, @Query("prefix") String prefix, @Query("recursive") boolean
        recursive, @Query("segmentId") String segmentId, @Query("maxResults") Integer maxResults, @Query("resource") String resource, @Query("timeout")
        Integer timeout, @Header("Authorization") String authorization, @Header("Date") DateTime dateProperty, @Header("x-ms-version") DateTime xMsVersion,
        @Header("x-ms-client-request-id") String xMsClientRequestId);

    @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.dfs.client.AzureDistributedFileSystemClient "
        + "getFilesystemProperties"})
    @HEAD("{filesystem}")
    Observable<Response<Void>> getFilesystemProperties(@Path("filesystem") String filesystem, @Query("resource") String resource, @Query("timeout")
        Integer timeout, @Header("Authorization") String authorization, @Header("Date") DateTime dateProperty, @Header("x-ms-version") DateTime xMsVersion,
        @Header("x-ms-client-request-id") String xMsClientRequestId);

    @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.dfs.client.AzureDistributedFileSystemClient "
        + "deleteFilesystem"})
    @HTTP(path = "{filesystem}", method = "DELETE", hasBody = true)
    Observable<Response<ResponseBody>> deleteFilesystem(@Path("filesystem") String filesystem, @Query("resource") String resource, @Query("timeout")
        Integer timeout, @Header("Authorization") String authorization, @Header("Date") DateTime dateProperty, @Header("x-ms-version") DateTime xMsVersion,
        @Header("x-ms-client-request-id") String xMsClientRequestId);

    @Headers({"Content-Type: application/octet-stream", "x-ms-logging-context: com.microsoft.azure.dfs.client.AzureDistributedFileSystemClient createPath"})

    @PUT("{filesystem}/{path}")
    Observable<Response<ResponseBody>> createPath(@Path("filesystem") String filesystem, @Path("path") String path, @Query("resource") String resource,
        @Header("Content-Length") String contentLength, @Header("Content-Type") ContentType contentType, @Header("Content-Encoding") String contentEncoding,
        @Header("Content-Language") String contentLanguage, @Header("Content-MD5") String contentMD5, @Header("x-ms-cache-control") String xMsCacheControl,
        @Header("x-ms-content-type") String xMsContentType, @Header("x-ms-content-encoding") String xMsContentEncoding, @Header("x-ms-content-language")
        String xMsContentLanguage, @Header("x-ms-content-md5") String xMsContentMd5, @Header("x-ms-rename-source") String xMsRenameSource, @Header
        ("x-ms-proposed-lease-id") String xMsProposedLeaseId, @Header("x-ms-properties") String xMsProperties, @Header("x-ms-origination-id") String
        xMsOriginationId, @Query("timeout") Integer timeout, @Header("Authorization") String authorization, @Header("Date") DateTime dateProperty, @Header
        ("x-ms-version") DateTime xMsVersion, @Header("x-ms-client-request-id") String xMsClientRequestId);

    @Headers({"Content-Type: application/octet-stream", "x-ms-logging-context: com.microsoft.azure.dfs.client.AzureDistributedFileSystemClient "
        + "updatePath"})
    @PATCH("{filesystem}/{path}")
    Observable<Response<ResponseBody>> updatePath(@Path("filesystem") String filesystem, @Path("path") String path, @Query("resource") String resource,
        @Query("component") String component, @Header("x-ms-lease-action") String xMsLeaseAction, @Query("position") Long position, @Query("x-ms-lease-id")
        String xMsLeaseId, @Header("Content-Length") String contentLength, @Header("Content-MD5") String contentMD5, @Header("x-ms-cache-control") String
        xMsCacheControl, @Header("x-ms-content-type") String xMsContentType, @Header("x-ms-content-encoding") String xMsContentEncoding, @Header
        ("x-ms-content-language") String xMsContentLanguage, @Header("x-ms-content-md5") String xMsContentMd5, @Header("x-ms-properties") String
        xMsProperties, @Query("timeout") Integer timeout, @Header("Authorization") String authorization, @Header("Date") DateTime dateProperty, @Header
        ("x-ms-version") DateTime xMsVersion, @Header("x-ms-client-request-id") String xMsClientRequestId);

    @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.dfs.client.AzureDistributedFileSystemClient "
        + "leasePath"})
    @POST("{filesystem}/{path}")
    Observable<Response<ResponseBody>> leasePath(@Path("filesystem") String filesystem, @Path("path") String path, @Header("x-ms-lease-action") String
        xMsLeaseAction, @Header("x-ms-lease-duration") Integer xMsLeaseDuration, @Header("x-ms-lease-id") String xMsLeaseId, @Query("timeout") Integer
        timeout, @Header("Authorization") String authorization, @Header("Date") DateTime dateProperty, @Header("x-ms-version") DateTime xMsVersion, @Header
        ("x-ms-client-request-id") String xMsClientRequestId);

    @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.dfs.client.AzureDistributedFileSystemClient "
        + "readPath"})
    @GET("{filesystem}/{path}")
    @Streaming
    Observable<Response<ResponseBody>> readPath(@Path("filesystem") String filesystem, @Path("path") String path, @Query("timeout") Integer timeout, @Header
        ("Authorization") String authorization, @Header("Date") DateTime dateProperty, @Header("x-ms-version") DateTime xMsVersion, @Header
        ("x-ms-client-request-id") String xMsClientRequestId);

    @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.dfs.client.AzureDistributedFileSystemClient "
        + "getPathProperties"})
    @HEAD("{filesystem}/{path}")
    Observable<Response<Void>> getPathProperties(@Path("filesystem") String filesystem, @Path("path") String path, @Query("timeout") Integer timeout, @Header
        ("Authorization") String authorization, @Header("Date") DateTime dateProperty, @Header("x-ms-version") DateTime xMsVersion, @Header
        ("x-ms-client-request-id") String xMsClientRequestId);

    @Headers({"Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.dfs.client.AzureDistributedFileSystemClient "
        + "deletePath"})
    @HTTP(path = "{filesystem}/{path}", method = "DELETE", hasBody = true)
    Observable<Response<ResponseBody>> deletePath(@Path("filesystem") String filesystem, @Path("path") String path, @Query("recursive") Boolean
        recursive, @Query("resource") String resource, @Header("x-ms-lease-id") String xMsLeaseId, @Query("timeout") Integer timeout, @Header
        ("Authorization") String authorization, @Header("Date") DateTime dateProperty, @Header("x-ms-version") DateTime xMsVersion, @Header
        ("x-ms-client-request-id") String xMsClientRequestId);

  }

  /**
   * Create Filesystem.
   * Create a filesystem rooted at the specified location. If the filesystem already exists, the operation fails.  This operation does not support
   * conditional HTTP requests.
   *
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void createFilesystem(String filesystem, String resource) {
    createFilesystemWithServiceResponseAsync(filesystem, resource).toBlocking().single().body();
  }

  /**
   * Create Filesystem.
   * Create a filesystem rooted at the specified location. If the filesystem already exists, the operation fails.  This operation does not support
   * conditional HTTP requests.
   *
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> createFilesystemAsync(String filesystem, String resource, final ServiceCallback<Void> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(createFilesystemWithServiceResponseAsync(filesystem, resource), serviceCallback);
  }

  /**
   * Create Filesystem.
   * Create a filesystem rooted at the specified location. If the filesystem already exists, the operation fails.  This operation does not support
   * conditional HTTP requests.
   *
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> createFilesystemAsync(String filesystem, String resource) {
    return createFilesystemWithServiceResponseAsync(filesystem, resource).map(new Func1<ServiceResponseWithHeaders<Void, CreateFilesystemHeaders>, Void>() {
      @Override
      public Void call(ServiceResponseWithHeaders<Void, CreateFilesystemHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Create Filesystem.
   * Create a filesystem rooted at the specified location. If the filesystem already exists, the operation fails.  This operation does not support
   * conditional HTTP requests.
   *
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, CreateFilesystemHeaders>> createFilesystemWithServiceResponseAsync(String filesystem, String resource) {
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (resource == null) {
      throw new IllegalArgumentException("Parameter resource is required and cannot be null.");
    }
    return service.createFilesystem(filesystem, this.xMsProperties(), this.xMsOriginationId(), resource, this.timeout(), this.authorization(), this
        .dateProperty(), this.xMsVersion(), this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, CreateFilesystemHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, CreateFilesystemHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<Void, CreateFilesystemHeaders> clientResponse = createFilesystemDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  private ServiceResponseWithHeaders<Void, CreateFilesystemHeaders> createFilesystemDelegate(Response<ResponseBody> response) throws ErrorSchemaException,
      IOException, IllegalArgumentException {
    return this.restClient().responseBuilderFactory().<Void, ErrorSchemaException>newInstance(this.serializerAdapter())
        .register(201, new TypeToken<Void>() {
        }.getType())
        .registerError(ErrorSchemaException.class)
        .buildWithHeaders(response, CreateFilesystemHeaders.class);
  }

  /**
   * Set Filesystem Properties.
   * Set properties for the filesystem.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for
   * Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param component The component to be updated.  Must be "properties" to set the properties of a filesystem.
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void setFilesystemProperties(String component, String filesystem, String resource) {
    setFilesystemPropertiesWithServiceResponseAsync(component, filesystem, resource).toBlocking().single().body();
  }

  /**
   * Set Filesystem Properties.
   * Set properties for the filesystem.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for
   * Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param component The component to be updated.  Must be "properties" to set the properties of a filesystem.
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> setFilesystemPropertiesAsync(String component, String filesystem, String resource, final ServiceCallback<Void> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(setFilesystemPropertiesWithServiceResponseAsync(component, filesystem, resource), serviceCallback);
  }

  /**
   * Set Filesystem Properties.
   * Set properties for the filesystem.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for
   * Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param component The component to be updated.  Must be "properties" to set the properties of a filesystem.
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> setFilesystemPropertiesAsync(String component, String filesystem, String resource) {
    return setFilesystemPropertiesWithServiceResponseAsync(component, filesystem, resource).map(new Func1<ServiceResponseWithHeaders<Void,
        SetFilesystemPropertiesHeaders>, Void>() {
      @Override
      public Void call(ServiceResponseWithHeaders<Void, SetFilesystemPropertiesHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Set Filesystem Properties.
   * Set properties for the filesystem.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for
   * Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param component The component to be updated.  Must be "properties" to set the properties of a filesystem.
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, SetFilesystemPropertiesHeaders>> setFilesystemPropertiesWithServiceResponseAsync(String component,
      String filesystem, String resource) {
    if (component == null) {
      throw new IllegalArgumentException("Parameter component is required and cannot be null.");
    }
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (resource == null) {
      throw new IllegalArgumentException("Parameter resource is required and cannot be null.");
    }
    return service.setFilesystemProperties(filesystem, component, this.xMsProperties(), resource, this.timeout(), this.authorization(), this.dateProperty(),
        this.xMsVersion(), this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, SetFilesystemPropertiesHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, SetFilesystemPropertiesHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<Void, SetFilesystemPropertiesHeaders> clientResponse = setFilesystemPropertiesDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  private ServiceResponseWithHeaders<Void, SetFilesystemPropertiesHeaders> setFilesystemPropertiesDelegate(Response<ResponseBody> response) throws
      ErrorSchemaException, IOException, IllegalArgumentException {
    return this.restClient().responseBuilderFactory().<Void, ErrorSchemaException>newInstance(this.serializerAdapter())
        .register(200, new TypeToken<Void>() {
        }.getType())
        .registerError(ErrorSchemaException.class)
        .buildWithHeaders(response, SetFilesystemPropertiesHeaders.class);
  }

  /**
   * List Paths.
   * List filesystem paths and their properties.
   *
   * @param recursive If "true", all paths are listed; otherwise, only paths at the root of the filesystem are listed.  If "prefix" is specified, the list
   *                  will only include paths that share the same root.
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   * @return the ListSchema object if successful.
   */
  public ListSchema listPaths(boolean recursive, String filesystem, String resource) {
    return listPathsWithServiceResponseAsync(recursive, filesystem, resource).toBlocking().single().body();
  }

  /**
   * List Paths.
   * List filesystem paths and their properties.
   *
   * @param recursive If "true", all paths are listed; otherwise, only paths at the root of the filesystem are listed.  If "prefix" is specified, the list
   *                  will only include paths that share the same root.
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<ListSchema> listPathsAsync(boolean recursive, String filesystem, String resource, final ServiceCallback<ListSchema> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(listPathsWithServiceResponseAsync(recursive, filesystem, resource), serviceCallback);
  }

  /**
   * List Paths.
   * List filesystem paths and their properties.
   *
   * @param recursive If "true", all paths are listed; otherwise, only paths at the root of the filesystem are listed.  If "prefix" is specified, the list
   *                  will only include paths that share the same root.
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the observable to the ListSchema object
   */
  public Observable<ListSchema> listPathsAsync(boolean recursive, String filesystem, String resource) {
    return listPathsWithServiceResponseAsync(recursive, filesystem, resource).map(new Func1<ServiceResponseWithHeaders<ListSchema, ListPathsHeaders>,
        ListSchema>() {
      @Override
      public ListSchema call(ServiceResponseWithHeaders<ListSchema, ListPathsHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * List Paths.
   * List filesystem paths and their properties.
   *
   * @param recursive If "true", all paths are listed; otherwise, only paths at the root of the filesystem are listed.  If "prefix" is specified, the list
   *                  will only include paths that share the same root.
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the observable to the ListSchema object
   */
  public Observable<ServiceResponseWithHeaders<ListSchema, ListPathsHeaders>> listPathsWithServiceResponseAsync(boolean recursive, String filesystem, String
      resource) {
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (resource == null) {
      throw new IllegalArgumentException("Parameter resource is required and cannot be null.");
    }
    final String prefix = null;
    final String segmentId = null;
    final Integer maxResults = null;
    return service.listPaths(filesystem, prefix, recursive, segmentId, maxResults, resource, this.timeout(), this.authorization(), this.dateProperty(), this
        .xMsVersion(), this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ListSchema, ListPathsHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<ListSchema, ListPathsHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<ListSchema, ListPathsHeaders> clientResponse = listPathsDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  /**
   * List Paths.
   * List filesystem paths and their properties.
   *
   * @param recursive If "true", all paths are listed; otherwise, only paths at the root of the filesystem are listed.  If "prefix" is specified, the list
   *                  will only include paths that share the same root.
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @param prefix Filter results to paths beginning with the specified prefix.
   * @param segmentId An optional value that identifies the segment of the list to be returned with the next list operation. The operation returns the
   *                  "segmentId" within the response body if the list returned was not complete. The "segmentId" may then be used in a subsequent call to
   *                  request the next segment of the list.
   * @param maxResults An optional value that specifies the maximum number of items to return. If omitted or greater than 5,000, the response will include up
   *                  to 5,000 items.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   * @return the ListSchema object if successful.
   */
  public ListSchema listPaths(boolean recursive, String filesystem, String resource, String prefix, String segmentId, Integer maxResults) {
    return listPathsWithServiceResponseAsync(recursive, filesystem, resource, prefix, segmentId, maxResults).toBlocking().single().body();
  }

  /**
   * List Paths.
   * List filesystem paths and their properties.
   *
   * @param recursive If "true", all paths are listed; otherwise, only paths at the root of the filesystem are listed.  If "prefix" is specified, the list
   *                  will only include paths that share the same root.
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @param prefix Filter results to paths beginning with the specified prefix.
   * @param segmentId An optional value that identifies the segment of the list to be returned with the next list operation. The operation returns the
   *                  "segmentId" within the response body if the list returned was not complete. The "segmentId" may then be used in a subsequent call to
   *                  request the next segment of the list.
   * @param maxResults An optional value that specifies the maximum number of items to return. If omitted or greater than 5,000, the response will include up
   *                  to 5,000 items.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<ListSchema> listPathsAsync(boolean recursive, String filesystem, String resource, String prefix, String segmentId, Integer maxResults,
      final ServiceCallback<ListSchema> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(listPathsWithServiceResponseAsync(recursive, filesystem, resource, prefix, segmentId, maxResults), serviceCallback);
  }

  /**
   * List Paths.
   * List filesystem paths and their properties.
   *
   * @param recursive If "true", all paths are listed; otherwise, only paths at the root of the filesystem are listed.  If "prefix" is specified, the list
   *                  will only include paths that share the same root.
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @param prefix Filter results to paths beginning with the specified prefix.
   * @param segmentId An optional value that identifies the segment of the list to be returned with the next list operation. The operation returns the
   *                  "segmentId" within the response body if the list returned was not complete. The "segmentId" may then be used in a subsequent call to
   *                  request the next segment of the list.
   * @param maxResults An optional value that specifies the maximum number of items to return. If omitted or greater than 5,000, the response will include up
   *                  to 5,000 items.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the observable to the ListSchema object
   */
  public Observable<ListSchema> listPathsAsync(boolean recursive, String filesystem, String resource, String prefix, String segmentId, Integer maxResults) {
    return listPathsWithServiceResponseAsync(recursive, filesystem, resource, prefix, segmentId, maxResults).map(new
      Func1<ServiceResponseWithHeaders<ListSchema, ListPathsHeaders>, ListSchema>() {
        @Override
        public ListSchema call(ServiceResponseWithHeaders<ListSchema, ListPathsHeaders> response) {
          return response.body();
        }
      });
  }

  /**
   * List Paths.
   * List filesystem paths and their properties.
   *
   * @param recursive If "true", all paths are listed; otherwise, only paths at the root of the filesystem are listed.  If "prefix" is specified, the list
   *                  will only include paths that share the same root.
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @param prefix Filter results to paths beginning with the specified prefix.
   * @param segmentId An optional value that identifies the segment of the list to be returned with the next list operation. The operation returns the
   *                  "segmentId" within the response body if the list returned was not complete. The "segmentId" may then be used in a subsequent call to
   *                  request the next segment of the list.
   * @param maxResults An optional value that specifies the maximum number of items to return. If omitted or greater than 5,000, the response will include up
   *                  to 5,000 items.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the observable to the ListSchema object
   */
  public Observable<ServiceResponseWithHeaders<ListSchema, ListPathsHeaders>> listPathsWithServiceResponseAsync(boolean recursive, String filesystem, String
      resource, String prefix, String segmentId, Integer maxResults) {
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (resource == null) {
      throw new IllegalArgumentException("Parameter resource is required and cannot be null.");
    }
    return service.listPaths(filesystem, prefix, recursive, segmentId, maxResults, resource, this.timeout(), this.authorization(), this.dateProperty(), this
        .xMsVersion(), this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<ListSchema, ListPathsHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<ListSchema, ListPathsHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<ListSchema, ListPathsHeaders> clientResponse = listPathsDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  private ServiceResponseWithHeaders<ListSchema, ListPathsHeaders> listPathsDelegate(Response<ResponseBody> response) throws ErrorSchemaException,
      IOException, IllegalArgumentException {
    return this.restClient().responseBuilderFactory().<ListSchema, ErrorSchemaException>newInstance(this.serializerAdapter())
        .register(200, new TypeToken<ListSchema>() {
        }.getType())
        .registerError(ErrorSchemaException.class)
        .buildWithHeaders(response, ListPathsHeaders.class);
  }

  /**
   * Get Filesystem Properties.
   * All system and user-defined filesystem properties are specified in the response headers.
   *
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void getFilesystemProperties(String filesystem, String resource) {
    getFilesystemPropertiesWithServiceResponseAsync(filesystem, resource).toBlocking().single().body();
  }

  /**
   * Get Filesystem Properties.
   * All system and user-defined filesystem properties are specified in the response headers.
   *
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> getFilesystemPropertiesAsync(String filesystem, String resource, final ServiceCallback<Void> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(getFilesystemPropertiesWithServiceResponseAsync(filesystem, resource), serviceCallback);
  }

  /**
   * Get Filesystem Properties.
   * All system and user-defined filesystem properties are specified in the response headers.
   *
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> getFilesystemPropertiesAsync(String filesystem, String resource) {
    return getFilesystemPropertiesWithServiceResponseAsync(filesystem, resource).map(new Func1<ServiceResponseWithHeaders<Void,
        GetFilesystemPropertiesHeaders>, Void>() {
      @Override
      public Void call(ServiceResponseWithHeaders<Void, GetFilesystemPropertiesHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Get Filesystem Properties.
   * All system and user-defined filesystem properties are specified in the response headers.
   *
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, GetFilesystemPropertiesHeaders>> getFilesystemPropertiesWithServiceResponseAsync(String filesystem,
      String resource) {
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (resource == null) {
      throw new IllegalArgumentException("Parameter resource is required and cannot be null.");
    }
    return service.getFilesystemProperties(filesystem, resource, this.timeout(), this.authorization(), this.dateProperty(), this.xMsVersion(), this
        .xMsClientRequestId())
        .flatMap(new Func1<Response<Void>, Observable<ServiceResponseWithHeaders<Void, GetFilesystemPropertiesHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, GetFilesystemPropertiesHeaders>> call(Response<Void> response) {
            try {
              ServiceResponseWithHeaders<Void, GetFilesystemPropertiesHeaders> clientResponse = getFilesystemPropertiesDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  private ServiceResponseWithHeaders<Void, GetFilesystemPropertiesHeaders> getFilesystemPropertiesDelegate(Response<Void> response) throws
      ErrorSchemaException, IOException, IllegalArgumentException {
    return this.restClient().responseBuilderFactory().<Void, ErrorSchemaException>newInstance(this.serializerAdapter())
        .register(200, new TypeToken<Void>() {
        }.getType())
        .registerError(ErrorSchemaException.class)
        .buildEmptyWithHeaders(response, GetFilesystemPropertiesHeaders.class);
  }

  /**
   * Delete Filesystem.
   * Marks the filesystem for deletion.  When a filesystem is deleted, a filesystem with the same identifier cannot be created for at least 30 seconds. While
   * the filesystem is being deleted, attempts to create a filesystem with the same identifier will fail with status code 409 (Conflict), with the service
   * returning additional error information indicating that the filesystem is being deleted. All other operations, including operations on any files or
   * directories within the filesystem, will fail with status code 404 (Not Found) while the filesystem is being deleted. This operation supports
   * conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void deleteFilesystem(String filesystem, String resource) {
    deleteFilesystemWithServiceResponseAsync(filesystem, resource).toBlocking().single().body();
  }

  /**
   * Delete Filesystem.
   * Marks the filesystem for deletion.  When a filesystem is deleted, a filesystem with the same identifier cannot be created for at least 30 seconds. While
   * the filesystem is being deleted, attempts to create a filesystem with the same identifier will fail with status code 409 (Conflict), with the service
   * returning additional error information indicating that the filesystem is being deleted. All other operations, including operations on any files or
   * directories within the filesystem, will fail with status code 404 (Not Found) while the filesystem is being deleted. This operation supports
   * conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> deleteFilesystemAsync(String filesystem, String resource, final ServiceCallback<Void> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(deleteFilesystemWithServiceResponseAsync(filesystem, resource), serviceCallback);
  }

  /**
   * Delete Filesystem.
   * Marks the filesystem for deletion.  When a filesystem is deleted, a filesystem with the same identifier cannot be created for at least 30 seconds. While
   * the filesystem is being deleted, attempts to create a filesystem with the same identifier will fail with status code 409 (Conflict), with the service
   * returning additional error information indicating that the filesystem is being deleted. All other operations, including operations on any files or
   * directories within the filesystem, will fail with status code 404 (Not Found) while the filesystem is being deleted. This operation supports
   * conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> deleteFilesystemAsync(String filesystem, String resource) {
    return deleteFilesystemWithServiceResponseAsync(filesystem, resource).map(new Func1<ServiceResponseWithHeaders<Void, DeleteFilesystemHeaders>, Void>() {
      @Override
      public Void call(ServiceResponseWithHeaders<Void, DeleteFilesystemHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Delete Filesystem.
   * Marks the filesystem for deletion.  When a filesystem is deleted, a filesystem with the same identifier cannot be created for at least 30 seconds. While
   * the filesystem is being deleted, attempts to create a filesystem with the same identifier will fail with status code 409 (Conflict), with the service
   * returning additional error information indicating that the filesystem is being deleted. All other operations, including operations on any files or
   * directories within the filesystem, will fail with status code 404 (Not Found) while the filesystem is being deleted. This operation supports
   * conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param filesystem The filesystem identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the dash
   *                   (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have between 3 and 63 characters.
   * @param resource The value must be "filesystem" for all filesystem operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, DeleteFilesystemHeaders>> deleteFilesystemWithServiceResponseAsync(String filesystem, String resource) {
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (resource == null) {
      throw new IllegalArgumentException("Parameter resource is required and cannot be null.");
    }
    return service.deleteFilesystem(filesystem, resource, this.timeout(), this.authorization(), this.dateProperty(), this.xMsVersion(), this
        .xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, DeleteFilesystemHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, DeleteFilesystemHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<Void, DeleteFilesystemHeaders> clientResponse = deleteFilesystemDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  private ServiceResponseWithHeaders<Void, DeleteFilesystemHeaders> deleteFilesystemDelegate(Response<ResponseBody> response) throws ErrorSchemaException,
      IOException, IllegalArgumentException {
    return this.restClient().responseBuilderFactory().<Void, ErrorSchemaException>newInstance(this.serializerAdapter())
        .register(202, new TypeToken<Void>() {
        }.getType())
        .registerError(ErrorSchemaException.class)
        .buildWithHeaders(response, DeleteFilesystemHeaders.class);
  }

  /**
   * Create File | Create Directory | Rename File | Rename Directory.
   * Create or rename a file or directory.    By default, the destination is overwritten and if the destination already exists and has a lease the lease is
   * broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations]
   * (https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination
   * already exists, use a conditional request with If-Nome-Match: "*".
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void createPath(String resource, String filesystem, String path) {
    createPathWithServiceResponseAsync(resource, filesystem, path).toBlocking().single().body();
  }

  /**
   * Create File | Create Directory | Rename File | Rename Directory.
   * Create or rename a file or directory.    By default, the destination is overwritten and if the destination already exists and has a lease the lease is
   * broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations]
   * (https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination
   * already exists, use a conditional request with If-Nome-Match: "*".
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> createPathAsync(String resource, String filesystem, String path, final ServiceCallback<Void> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(createPathWithServiceResponseAsync(resource, filesystem, path), serviceCallback);
  }

  /**
   * Create File | Create Directory | Rename File | Rename Directory.
   * Create or rename a file or directory.    By default, the destination is overwritten and if the destination already exists and has a lease the lease is
   * broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations]
   * (https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination
   * already exists, use a conditional request with If-Nome-Match: "*".
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> createPathAsync(String resource, String filesystem, String path) {
    return createPathWithServiceResponseAsync(resource, filesystem, path).map(new Func1<ServiceResponseWithHeaders<Void, CreatePathHeaders>, Void>() {
      @Override
      public Void call(ServiceResponseWithHeaders<Void, CreatePathHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Create File | Create Directory | Rename File | Rename Directory.
   * Create or rename a file or directory.    By default, the destination is overwritten and if the destination already exists and has a lease the lease is
   * broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations]
   * (https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination
   * already exists, use a conditional request with If-Nome-Match: "*".
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, CreatePathHeaders>> createPathWithServiceResponseAsync(String resource, String filesystem, String path) {
    if (resource == null) {
      throw new IllegalArgumentException("Parameter resource is required and cannot be null.");
    }
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (path == null) {
      throw new IllegalArgumentException("Parameter path is required and cannot be null.");
    }
    final String contentLength = null;
    final ContentType contentType = null;
    final String contentEncoding = null;
    final String contentLanguage = null;
    final String contentMD5 = null;
    final String xMsCacheControl = null;
    final String xMsContentType = null;
    final String xMsContentEncoding = null;
    final String xMsContentLanguage = null;
    final String xMsContentMd5 = null;
    final String xMsRenameSource = null;
    final String xMsProposedLeaseId = null;
    return service.createPath(filesystem, path, resource, contentLength, contentType, contentEncoding, contentLanguage, contentMD5, xMsCacheControl,
        xMsContentType, xMsContentEncoding, xMsContentLanguage, xMsContentMd5, xMsRenameSource, xMsProposedLeaseId, this.xMsProperties(),
        this.xMsOriginationId(), this.timeout(), this.authorization(), this.dateProperty(), this.xMsVersion(), this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, CreatePathHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, CreatePathHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<Void, CreatePathHeaders> clientResponse = createPathDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  /**
   * Create File | Create Directory | Rename File | Rename Directory.
   * Create or rename a file or directory.    By default, the destination is overwritten and if the destination already exists and has a lease the lease is
   * broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations]
   * (https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination
   * already exists, use a conditional request with If-Nome-Match: "*".
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param contentLength Required for "Create File" and "Create Directory".  Must be 0 to create a directory or empty file.  Must be greater than 0 and less
   *                     than or equal to 268,435,456 (256 MB) to create a file with content.
   * @param contentType Optional.  The MIME type for a file.  The default is "application/octet-stream". Possible values include: 'application/octet-stream',
   *                   'text/plain'
   * @param contentEncoding Optional.  Specifies which content encodings have been applied to the file. This value is returned to the client when the "Read
   *                        File" operation is performed.
   * @param contentLanguage Optional.  Specifies the natural language used by the intended audience for the file.
   * @param contentMD5 Optional.  An MD5 hash of the blob content. This hash is used to verify the integrity of the blob during transport. When this header
   *                   is specified, the storage service validates the hash. If the two hashes do not match, the operation will fail with error code 400 (Bad
   *                   Request).
   * @param xMsCacheControl Optional.  The service stores this value and includes it in the "Cache-Control" response header for "Read File" operations.
   * @param xMsContentType Optional.  The service stores this value and includes it in the "Content-Type" response header for "Read File" operations.
   * @param xMsContentEncoding Optional.  The service stores this value and includes it in the "Content-Encoding" response header for "Read File" operations.
   * @param xMsContentLanguage Optional.  The service stores this value and includes it in the "Content-Language" response header for "Read File" operations.
   * @param xMsContentMd5 Optional.  The service stores this value and includes it in the "Content-MD5" response header for "Read File" operations.
   * @param xMsRenameSource An optional file or directory to be renamed.  The value must have the following format: "/{filesysystem}/{path}".  If
   *                        "x-ms-properties" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be
   *                        preserved.
   * @param xMsProposedLeaseId Optionally, a lease can be acquired using the proposed ID when the resource is created.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void createPath(String resource, String filesystem, String path, String contentLength, ContentType contentType, String contentEncoding, String
      contentLanguage, String contentMD5, String xMsCacheControl, String xMsContentType, String xMsContentEncoding, String xMsContentLanguage, String
      xMsContentMd5, String xMsRenameSource, String xMsProposedLeaseId) {
    createPathWithServiceResponseAsync(resource, filesystem, path, contentLength, contentType, contentEncoding, contentLanguage, contentMD5, xMsCacheControl,
        xMsContentType, xMsContentEncoding, xMsContentLanguage, xMsContentMd5, xMsRenameSource, xMsProposedLeaseId).toBlocking().single().body();
  }

  /**
   * Create File | Create Directory | Rename File | Rename Directory.
   * Create or rename a file or directory.    By default, the destination is overwritten and if the destination already exists and has a lease the lease is
   * broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations]
   * (https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination
   * already exists, use a conditional request with If-Nome-Match: "*".
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param contentLength Required for "Create File" and "Create Directory".  Must be 0 to create a directory or empty file.  Must be greater than 0 and less
   *                     than or equal to 268,435,456 (256 MB) to create a file with content.
   * @param contentType Optional.  The MIME type for a file.  The default is "application/octet-stream". Possible values include: 'application/octet-stream',
   *                   'text/plain'
   * @param contentEncoding Optional.  Specifies which content encodings have been applied to the file. This value is returned to the client when the "Read
   *                        File" operation is performed.
   * @param contentLanguage Optional.  Specifies the natural language used by the intended audience for the file.
   * @param contentMD5 Optional.  An MD5 hash of the blob content. This hash is used to verify the integrity of the blob during transport. When this header
   *                   is specified, the storage service validates the hash. If the two hashes do not match, the operation will fail with error code 400 (Bad
   *                   Request).
   * @param xMsCacheControl Optional.  The service stores this value and includes it in the "Cache-Control" response header for "Read File" operations.
   * @param xMsContentType Optional.  The service stores this value and includes it in the "Content-Type" response header for "Read File" operations.
   * @param xMsContentEncoding Optional.  The service stores this value and includes it in the "Content-Encoding" response header for "Read File" operations.
   * @param xMsContentLanguage Optional.  The service stores this value and includes it in the "Content-Language" response header for "Read File" operations.
   * @param xMsContentMd5 Optional.  The service stores this value and includes it in the "Content-MD5" response header for "Read File" operations.
   * @param xMsRenameSource An optional file or directory to be renamed.  The value must have the following format: "/{filesysystem}/{path}".  If
   *                        "x-ms-properties" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be
   *                        preserved.
   * @param xMsProposedLeaseId Optionally, a lease can be acquired using the proposed ID when the resource is created.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> createPathAsync(String resource, String filesystem, String path, String contentLength, ContentType contentType, String
      contentEncoding, String contentLanguage, String contentMD5, String xMsCacheControl, String xMsContentType, String xMsContentEncoding, String
      xMsContentLanguage, String xMsContentMd5, String xMsRenameSource, String xMsProposedLeaseId, final ServiceCallback<Void> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(createPathWithServiceResponseAsync(resource, filesystem, path, contentLength, contentType, contentEncoding,
        contentLanguage, contentMD5, xMsCacheControl, xMsContentType, xMsContentEncoding, xMsContentLanguage, xMsContentMd5, xMsRenameSource,
        xMsProposedLeaseId), serviceCallback);
  }

  /**
   * Create File | Create Directory | Rename File | Rename Directory.
   * Create or rename a file or directory.    By default, the destination is overwritten and if the destination already exists and has a lease the lease is
   * broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations]
   * (https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination
   * already exists, use a conditional request with If-Nome-Match: "*".
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param contentLength Required for "Create File" and "Create Directory".  Must be 0 to create a directory or empty file.  Must be greater than 0 and less
   *                     than or equal to 268,435,456 (256 MB) to create a file with content.
   * @param contentType Optional.  The MIME type for a file.  The default is "application/octet-stream". Possible values include: 'application/octet-stream',
   *                   'text/plain'
   * @param contentEncoding Optional.  Specifies which content encodings have been applied to the file. This value is returned to the client when the "Read
   *                        File" operation is performed.
   * @param contentLanguage Optional.  Specifies the natural language used by the intended audience for the file.
   * @param contentMD5 Optional.  An MD5 hash of the blob content. This hash is used to verify the integrity of the blob during transport. When this header
   *                   is specified, the storage service validates the hash. If the two hashes do not match, the operation will fail with error code 400 (Bad
   *                   Request).
   * @param xMsCacheControl Optional.  The service stores this value and includes it in the "Cache-Control" response header for "Read File" operations.
   * @param xMsContentType Optional.  The service stores this value and includes it in the "Content-Type" response header for "Read File" operations.
   * @param xMsContentEncoding Optional.  The service stores this value and includes it in the "Content-Encoding" response header for "Read File" operations.
   * @param xMsContentLanguage Optional.  The service stores this value and includes it in the "Content-Language" response header for "Read File" operations.
   * @param xMsContentMd5 Optional.  The service stores this value and includes it in the "Content-MD5" response header for "Read File" operations.
   * @param xMsRenameSource An optional file or directory to be renamed.  The value must have the following format: "/{filesysystem}/{path}".  If
   *                        "x-ms-properties" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be
   *                        preserved.
   * @param xMsProposedLeaseId Optionally, a lease can be acquired using the proposed ID when the resource is created.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> createPathAsync(String resource, String filesystem, String path, String contentLength, ContentType contentType, String
      contentEncoding, String contentLanguage, String contentMD5, String xMsCacheControl, String xMsContentType, String xMsContentEncoding, String
      xMsContentLanguage, String xMsContentMd5, String xMsRenameSource, String xMsProposedLeaseId) {
    return createPathWithServiceResponseAsync(resource, filesystem, path, contentLength, contentType, contentEncoding, contentLanguage, contentMD5,
        xMsCacheControl, xMsContentType, xMsContentEncoding, xMsContentLanguage, xMsContentMd5, xMsRenameSource, xMsProposedLeaseId).map(new
        Func1<ServiceResponseWithHeaders<Void, CreatePathHeaders>, Void>() {
          @Override
          public Void call(ServiceResponseWithHeaders<Void, CreatePathHeaders> response) {
            return response.body();
          }
        });
  }

  /**
   * Create File | Create Directory | Rename File | Rename Directory.
   * Create or rename a file or directory.    By default, the destination is overwritten and if the destination already exists and has a lease the lease is
   * broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations]
   * (https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination
   * already exists, use a conditional request with If-Nome-Match: "*".
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param contentLength Required for "Create File" and "Create Directory".  Must be 0 to create a directory or empty file.  Must be greater than 0 and less
   *                     than or equal to 268,435,456 (256 MB) to create a file with content.
   * @param contentType Optional.  The MIME type for a file.  The default is "application/octet-stream". Possible values include: 'application/octet-stream',
   *                   'text/plain'
   * @param contentEncoding Optional.  Specifies which content encodings have been applied to the file. This value is returned to the client when the "Read
   *                        File" operation is performed.
   * @param contentLanguage Optional.  Specifies the natural language used by the intended audience for the file.
   * @param contentMD5 Optional.  An MD5 hash of the blob content. This hash is used to verify the integrity of the blob during transport. When this header
   *                   is specified, the storage service validates the hash. If the two hashes do not match, the operation will fail with error code 400 (Bad
   *                   Request).
   * @param xMsCacheControl Optional.  The service stores this value and includes it in the "Cache-Control" response header for "Read File" operations.
   * @param xMsContentType Optional.  The service stores this value and includes it in the "Content-Type" response header for "Read File" operations.
   * @param xMsContentEncoding Optional.  The service stores this value and includes it in the "Content-Encoding" response header for "Read File" operations.
   * @param xMsContentLanguage Optional.  The service stores this value and includes it in the "Content-Language" response header for "Read File" operations.
   * @param xMsContentMd5 Optional.  The service stores this value and includes it in the "Content-MD5" response header for "Read File" operations.
   * @param xMsRenameSource An optional file or directory to be renamed.  The value must have the following format: "/{filesysystem}/{path}".  If
   *                        "x-ms-properties" is specified, the properties will overwrite the existing properties; otherwise, the existing properties will be
   *                        preserved.
   * @param xMsProposedLeaseId Optionally, a lease can be acquired using the proposed ID when the resource is created.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, CreatePathHeaders>> createPathWithServiceResponseAsync(String resource, String filesystem, String path,
      String contentLength, ContentType contentType, String contentEncoding, String contentLanguage, String contentMD5, String xMsCacheControl, String
      xMsContentType, String xMsContentEncoding, String xMsContentLanguage, String xMsContentMd5, String xMsRenameSource, String xMsProposedLeaseId) {
    if (resource == null) {
      throw new IllegalArgumentException("Parameter resource is required and cannot be null.");
    }
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (path == null) {
      throw new IllegalArgumentException("Parameter path is required and cannot be null.");
    }
    return service.createPath(filesystem, path, resource, contentLength, contentType, contentEncoding, contentLanguage, contentMD5, xMsCacheControl,
        xMsContentType, xMsContentEncoding, xMsContentLanguage, xMsContentMd5, xMsRenameSource, xMsProposedLeaseId, this.xMsProperties(),
        this.xMsOriginationId(), this.timeout(), this.authorization(), this.dateProperty(), this.xMsVersion(), this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, CreatePathHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, CreatePathHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<Void, CreatePathHeaders> clientResponse = createPathDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  private ServiceResponseWithHeaders<Void, CreatePathHeaders> createPathDelegate(Response<ResponseBody> response) throws ErrorSchemaException, IOException,
      IllegalArgumentException {
    return this.restClient().responseBuilderFactory().<Void, ErrorSchemaException>newInstance(this.serializerAdapter())
        .register(201, new TypeToken<Void>() {
        }.getType())
        .registerError(ErrorSchemaException.class)
        .buildWithHeaders(response, CreatePathHeaders.class);
  }

  /**
   * Append Data | Flush Data | Set File Properties | Set Directory Properties.
   * Uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, or sets properties for a file or directory.  Data can only
   * be appended to a file.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void updatePath(String resource, String filesystem, String path) {
    updatePathWithServiceResponseAsync(resource, filesystem, path).toBlocking().single().body();
  }

  /**
   * Append Data | Flush Data | Set File Properties | Set Directory Properties.
   * Uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, or sets properties for a file or directory.  Data can only
   * be appended to a file.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> updatePathAsync(String resource, String filesystem, String path, final ServiceCallback<Void> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(updatePathWithServiceResponseAsync(resource, filesystem, path), serviceCallback);
  }

  /**
   * Append Data | Flush Data | Set File Properties | Set Directory Properties.
   * Uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, or sets properties for a file or directory.  Data can only
   * be appended to a file.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> updatePathAsync(String resource, String filesystem, String path) {
    return updatePathWithServiceResponseAsync(resource, filesystem, path).map(new Func1<ServiceResponseWithHeaders<Void, UpdatePathHeaders>, Void>() {
      @Override
      public Void call(ServiceResponseWithHeaders<Void, UpdatePathHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Append Data | Flush Data | Set File Properties | Set Directory Properties.
   * Uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, or sets properties for a file or directory.  Data can only
   * be appended to a file.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, UpdatePathHeaders>> updatePathWithServiceResponseAsync(String resource, String filesystem, String path) {
    if (resource == null) {
      throw new IllegalArgumentException("Parameter resource is required and cannot be null.");
    }
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (path == null) {
      throw new IllegalArgumentException("Parameter path is required and cannot be null.");
    }
    final String component = null;
    final String xMsLeaseAction = null;
    final Long position = null;
    final String xMsLeaseId = null;
    final String contentLength = null;
    final String contentMD5 = null;
    final String xMsCacheControl = null;
    final String xMsContentType = null;
    final String xMsContentEncoding = null;
    final String xMsContentLanguage = null;
    final String xMsContentMd5 = null;
    return service.updatePath(filesystem, path, resource, component, xMsLeaseAction, position, xMsLeaseId, contentLength, contentMD5, xMsCacheControl,
        xMsContentType, xMsContentEncoding, xMsContentLanguage, xMsContentMd5, this.xMsProperties(), this.timeout(), this.authorization(), this.dateProperty(),
        this.xMsVersion(), this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, UpdatePathHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, UpdatePathHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<Void, UpdatePathHeaders> clientResponse = updatePathDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  /**
   * Append Data | Flush Data | Set File Properties | Set Directory Properties.
   * Uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, or sets properties for a file or directory.  Data can only
   * be appended to a file.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param component The component to be updated.  Must be "data" to upload data to be appended to a file or to flush previously uploaded data to a file.
   *                  Must be "properties" to only set the properties of a file or directory.
   * @param xMsLeaseAction Optional.  The lease action can be "renew" to renew an existing lease or "release" to release a lease.
   * @param position This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.  It is required
   *                 when uploading data to be appended to the file and when flushing previously uploaded data to the file.  The value must be the position
   *                 where the data is to be appended.  Uploaded data is not immediately flushed, or written, to the file.  To flush, the previously uploaded
   *                 data must be contiguous, the position parameter must be specified and equal to the length of the file after all data has been written,
   *                 and there must not be a request entity body included with the request.
   * @param xMsLeaseId The lease ID must be specified if there is an active lease.
   * @param contentLength Required for "Append Data" and "Flush Data".  Must be 0 for "Flush Data".  Must be the length of the request content in bytes for
   *                      "Append Data".
   * @param contentMD5 Optional.  An MD5 hash of the request content. This hash is used to verify the integrity of the content during transport.
   * @param xMsCacheControl Optional.  The service stores this value and includes it in the "Cache-Control" response header for "Read File" operations.
   * @param xMsContentType Optional.  The service stores this value and includes it in the "Content-Type" response header for "Read File" operations.
   * @param xMsContentEncoding Optional.  The service stores this value and includes it in the "Content-Encoding" response header for "Read File" operations.
   * @param xMsContentLanguage Optional.  The service stores this value and includes it in the "Content-Language" response header for "Read File" operations.
   * @param xMsContentMd5 Optional.  The service stores this value and includes it in the "Content-MD5" response header for "Read File" operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void updatePath(String resource, String filesystem, String path, String component, String xMsLeaseAction, Long position, String xMsLeaseId, String
      contentLength, String contentMD5, String xMsCacheControl, String xMsContentType, String xMsContentEncoding, String xMsContentLanguage,
      String xMsContentMd5) {
    updatePathWithServiceResponseAsync(resource, filesystem, path, component, xMsLeaseAction, position, xMsLeaseId, contentLength, contentMD5,
        xMsCacheControl, xMsContentType, xMsContentEncoding, xMsContentLanguage, xMsContentMd5).toBlocking().single().body();
  }

  /**
   * Append Data | Flush Data | Set File Properties | Set Directory Properties.
   * Uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, or sets properties for a file or directory.  Data can only
   * be appended to a file.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param component The component to be updated.  Must be "data" to upload data to be appended to a file or to flush previously uploaded data to a file.
   *                  Must be "properties" to only set the properties of a file or directory.
   * @param xMsLeaseAction Optional.  The lease action can be "renew" to renew an existing lease or "release" to release a lease.
   * @param position This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.  It is required
   *                 when uploading data to be appended to the file and when flushing previously uploaded data to the file.  The value must be the position
   *                 where the data is to be appended.  Uploaded data is not immediately flushed, or written, to the file.  To flush, the previously uploaded
   *                 data must be contiguous, the position parameter must be specified and equal to the length of the file after all data has been written,
   *                 and there must not be a request entity body included with the request.
   * @param xMsLeaseId The lease ID must be specified if there is an active lease.
   * @param contentLength Required for "Append Data" and "Flush Data".  Must be 0 for "Flush Data".  Must be the length of the request content in bytes for
   *                      "Append Data".
   * @param contentMD5 Optional.  An MD5 hash of the request content. This hash is used to verify the integrity of the content during transport.
   * @param xMsCacheControl Optional.  The service stores this value and includes it in the "Cache-Control" response header for "Read File" operations.
   * @param xMsContentType Optional.  The service stores this value and includes it in the "Content-Type" response header for "Read File" operations.
   * @param xMsContentEncoding Optional.  The service stores this value and includes it in the "Content-Encoding" response header for "Read File" operations.
   * @param xMsContentLanguage Optional.  The service stores this value and includes it in the "Content-Language" response header for "Read File" operations.
   * @param xMsContentMd5 Optional.  The service stores this value and includes it in the "Content-MD5" response header for "Read File" operations.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> updatePathAsync(String resource, String filesystem, String path, String component, String xMsLeaseAction, Long position, String
      xMsLeaseId, String contentLength, String contentMD5, String xMsCacheControl, String xMsContentType, String xMsContentEncoding, String xMsContentLanguage,
      String xMsContentMd5, final ServiceCallback<Void> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(updatePathWithServiceResponseAsync(resource, filesystem, path, component, xMsLeaseAction, position, xMsLeaseId,
        contentLength, contentMD5, xMsCacheControl, xMsContentType, xMsContentEncoding, xMsContentLanguage, xMsContentMd5), serviceCallback);
  }

  /**
   * Append Data | Flush Data | Set File Properties | Set Directory Properties.
   * Uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, or sets properties for a file or directory.  Data can only
   * be appended to a file.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param component The component to be updated.  Must be "data" to upload data to be appended to a file or to flush previously uploaded data to a file.
   *                  Must be "properties" to only set the properties of a file or directory.
   * @param xMsLeaseAction Optional.  The lease action can be "renew" to renew an existing lease or "release" to release a lease.
   * @param position This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.  It is required
   *                 when uploading data to be appended to the file and when flushing previously uploaded data to the file.  The value must be the position
   *                 where the data is to be appended.  Uploaded data is not immediately flushed, or written, to the file.  To flush, the previously uploaded
   *                 data must be contiguous, the position parameter must be specified and equal to the length of the file after all data has been written,
   *                 and there must not be a request entity body included with the request.
   * @param xMsLeaseId The lease ID must be specified if there is an active lease.
   * @param contentLength Required for "Append Data" and "Flush Data".  Must be 0 for "Flush Data".  Must be the length of the request content in bytes for
   *                      "Append Data".
   * @param contentMD5 Optional.  An MD5 hash of the request content. This hash is used to verify the integrity of the content during transport.
   * @param xMsCacheControl Optional.  The service stores this value and includes it in the "Cache-Control" response header for "Read File" operations.
   * @param xMsContentType Optional.  The service stores this value and includes it in the "Content-Type" response header for "Read File" operations.
   * @param xMsContentEncoding Optional.  The service stores this value and includes it in the "Content-Encoding" response header for "Read File" operations.
   * @param xMsContentLanguage Optional.  The service stores this value and includes it in the "Content-Language" response header for "Read File" operations.
   * @param xMsContentMd5 Optional.  The service stores this value and includes it in the "Content-MD5" response header for "Read File" operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> updatePathAsync(String resource, String filesystem, String path, String component, String xMsLeaseAction, Long position, String
      xMsLeaseId, String contentLength, String contentMD5, String xMsCacheControl, String xMsContentType, String xMsContentEncoding, String xMsContentLanguage,
      String xMsContentMd5) {
    return updatePathWithServiceResponseAsync(resource, filesystem, path, component, xMsLeaseAction, position, xMsLeaseId, contentLength, contentMD5,
        xMsCacheControl, xMsContentType, xMsContentEncoding, xMsContentLanguage, xMsContentMd5).map(new Func1<ServiceResponseWithHeaders<Void,
        UpdatePathHeaders>, Void>() {
      @Override
      public Void call(ServiceResponseWithHeaders<Void, UpdatePathHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Append Data | Flush Data | Set File Properties | Set Directory Properties.
   * Uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, or sets properties for a file or directory.  Data can only
   * be appended to a file.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param component The component to be updated.  Must be "data" to upload data to be appended to a file or to flush previously uploaded data to a file.
   *                  Must be "properties" to only set the properties of a file or directory.
   * @param xMsLeaseAction Optional.  The lease action can be "renew" to renew an existing lease or "release" to release a lease.
   * @param position This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.  It is required
   *                 when uploading data to be appended to the file and when flushing previously uploaded data to the file.  The value must be the position
   *                 where the data is to be appended.  Uploaded data is not immediately flushed, or written, to the file.  To flush, the previously uploaded
   *                 data must be contiguous, the position parameter must be specified and equal to the length of the file after all data has been written,
   *                 and there must not be a request entity body included with the request.
   * @param xMsLeaseId The lease ID must be specified if there is an active lease.
   * @param contentLength Required for "Append Data" and "Flush Data".  Must be 0 for "Flush Data".  Must be the length of the request content in bytes for
   *                      "Append Data".
   * @param contentMD5 Optional.  An MD5 hash of the request content. This hash is used to verify the integrity of the content during transport.
   * @param xMsCacheControl Optional.  The service stores this value and includes it in the "Cache-Control" response header for "Read File" operations.
   * @param xMsContentType Optional.  The service stores this value and includes it in the "Content-Type" response header for "Read File" operations.
   * @param xMsContentEncoding Optional.  The service stores this value and includes it in the "Content-Encoding" response header for "Read File" operations.
   * @param xMsContentLanguage Optional.  The service stores this value and includes it in the "Content-Language" response header for "Read File" operations.
   * @param xMsContentMd5 Optional.  The service stores this value and includes it in the "Content-MD5" response header for "Read File" operations.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, UpdatePathHeaders>> updatePathWithServiceResponseAsync(String resource, String filesystem, String path,
      String component, String xMsLeaseAction, Long position, String xMsLeaseId, String contentLength, String contentMD5, String xMsCacheControl, String
      xMsContentType, String xMsContentEncoding, String xMsContentLanguage, String xMsContentMd5) {
    if (resource == null) {
      throw new IllegalArgumentException("Parameter resource is required and cannot be null.");
    }
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (path == null) {
      throw new IllegalArgumentException("Parameter path is required and cannot be null.");
    }
    return service.updatePath(filesystem, path, resource, component, xMsLeaseAction, position, xMsLeaseId, contentLength, contentMD5, xMsCacheControl,
        xMsContentType, xMsContentEncoding, xMsContentLanguage, xMsContentMd5, this.xMsProperties(), this.timeout(), this.authorization(), this.dateProperty(),
        this.xMsVersion(), this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, UpdatePathHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, UpdatePathHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<Void, UpdatePathHeaders> clientResponse = updatePathDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  private ServiceResponseWithHeaders<Void, UpdatePathHeaders> updatePathDelegate(Response<ResponseBody> response) throws ErrorSchemaException, IOException,
      IllegalArgumentException {
    return this.restClient().responseBuilderFactory().<Void, ErrorSchemaException>newInstance(this.serializerAdapter())
        .register(200, new TypeToken<Void>() {
        }.getType())
        .register(202, new TypeToken<Void>() {
        }.getType())
        .registerError(ErrorSchemaException.class)
        .buildWithHeaders(response, UpdatePathHeaders.class);
  }

  /**
   * Lease Path.
   * Create and manage a lease to restrict write and delete access to the path. This operation supports conditional HTTP requests.  For more information, see
   * [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param xMsLeaseAction There are three lease actions: "acquire", "renew", and "release".  Use "acquire" and specify the "x-ms-lease-duration" to create a
   *                      new file lease.  Use "renew" and specify the "leaseId" to renew an existing lease.  Use "release" and specify the "leaseId" to
   *                      release a lease.
   * @param xMsLeaseId The lease ID must be specified.  For the acquire action, this is the proposed ID for the new lease.  For the renew and release
   *                   actions, this must match the current lease ID.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void leasePath(String xMsLeaseAction, String xMsLeaseId, String filesystem, String path) {
    leasePathWithServiceResponseAsync(xMsLeaseAction, xMsLeaseId, filesystem, path).toBlocking().single().body();
  }

  /**
   * Lease Path.
   * Create and manage a lease to restrict write and delete access to the path. This operation supports conditional HTTP requests.  For more information, see
   * [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param xMsLeaseAction There are three lease actions: "acquire", "renew", and "release".  Use "acquire" and specify the "x-ms-lease-duration" to create a
   *                      new file lease.  Use "renew" and specify the "leaseId" to renew an existing lease.  Use "release" and specify the "leaseId" to
   *                      release a lease.
   * @param xMsLeaseId The lease ID must be specified.  For the acquire action, this is the proposed ID for the new lease.  For the renew and release
   *                   actions, this must match the current lease ID.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> leasePathAsync(String xMsLeaseAction, String xMsLeaseId, String filesystem, String path, final ServiceCallback<Void>
      serviceCallback) {
    return ServiceFuture.fromHeaderResponse(leasePathWithServiceResponseAsync(xMsLeaseAction, xMsLeaseId, filesystem, path), serviceCallback);
  }

  /**
   * Lease Path.
   * Create and manage a lease to restrict write and delete access to the path. This operation supports conditional HTTP requests.  For more information, see
   * [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param xMsLeaseAction There are three lease actions: "acquire", "renew", and "release".  Use "acquire" and specify the "x-ms-lease-duration" to create a
   *                      new file lease.  Use "renew" and specify the "leaseId" to renew an existing lease.  Use "release" and specify the "leaseId" to
   *                      release a lease.
   * @param xMsLeaseId The lease ID must be specified.  For the acquire action, this is the proposed ID for the new lease.  For the renew and release
   *                   actions, this must match the current lease ID.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> leasePathAsync(String xMsLeaseAction, String xMsLeaseId, String filesystem, String path) {
    return leasePathWithServiceResponseAsync(xMsLeaseAction, xMsLeaseId, filesystem, path).map(new Func1<ServiceResponseWithHeaders<Void, LeasePathHeaders>,
        Void>() {
      @Override
      public Void call(ServiceResponseWithHeaders<Void, LeasePathHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Lease Path.
   * Create and manage a lease to restrict write and delete access to the path. This operation supports conditional HTTP requests.  For more information, see
   * [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param xMsLeaseAction There are three lease actions: "acquire", "renew", and "release".  Use "acquire" and specify the "x-ms-lease-duration" to create a
   *                      new file lease.  Use "renew" and specify the "leaseId" to renew an existing lease.  Use "release" and specify the "leaseId" to
   *                      release a lease.
   * @param xMsLeaseId The lease ID must be specified.  For the acquire action, this is the proposed ID for the new lease.  For the renew and release
   *                   actions, this must match the current lease ID.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, LeasePathHeaders>> leasePathWithServiceResponseAsync(String xMsLeaseAction, String xMsLeaseId, String
      filesystem, String path) {
    if (xMsLeaseAction == null) {
      throw new IllegalArgumentException("Parameter xMsLeaseAction is required and cannot be null.");
    }
    if (xMsLeaseId == null) {
      throw new IllegalArgumentException("Parameter xMsLeaseId is required and cannot be null.");
    }
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (path == null) {
      throw new IllegalArgumentException("Parameter path is required and cannot be null.");
    }
    final Integer xMsLeaseDuration = null;
    return service.leasePath(filesystem, path, xMsLeaseAction, xMsLeaseDuration, xMsLeaseId, this.timeout(), this.authorization(), this.dateProperty(), this
        .xMsVersion(), this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, LeasePathHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, LeasePathHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<Void, LeasePathHeaders> clientResponse = leasePathDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  /**
   * Lease Path.
   * Create and manage a lease to restrict write and delete access to the path. This operation supports conditional HTTP requests.  For more information, see
   * [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param xMsLeaseAction There are three lease actions: "acquire", "renew", and "release".  Use "acquire" and specify the "x-ms-lease-duration" to create a
   *                      new file lease.  Use "renew" and specify the "leaseId" to renew an existing lease.  Use "release" and specify the "leaseId" to
   *                      release a lease.
   * @param xMsLeaseId The lease ID must be specified.  For the acquire action, this is the proposed ID for the new lease.  For the renew and release
   *                   actions, this must match the current lease ID.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param xMsLeaseDuration The lease duration is required to acquire a lease, and specifies the duration of the lease in seconds.  The lease duration must
   *                         be between 15 and 60 seconds.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void leasePath(String xMsLeaseAction, String xMsLeaseId, String filesystem, String path, Integer xMsLeaseDuration) {
    leasePathWithServiceResponseAsync(xMsLeaseAction, xMsLeaseId, filesystem, path, xMsLeaseDuration).toBlocking().single().body();
  }

  /**
   * Lease Path.
   * Create and manage a lease to restrict write and delete access to the path. This operation supports conditional HTTP requests.  For more information, see
   * [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param xMsLeaseAction There are three lease actions: "acquire", "renew", and "release".  Use "acquire" and specify the "x-ms-lease-duration" to create a
   *                      new file lease.  Use "renew" and specify the "leaseId" to renew an existing lease.  Use "release" and specify the "leaseId" to
   *                      release a lease.
   * @param xMsLeaseId The lease ID must be specified.  For the acquire action, this is the proposed ID for the new lease.  For the renew and release
   *                   actions, this must match the current lease ID.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param xMsLeaseDuration The lease duration is required to acquire a lease, and specifies the duration of the lease in seconds.  The lease duration must
   *                         be between 15 and 60 seconds.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> leasePathAsync(String xMsLeaseAction, String xMsLeaseId, String filesystem, String path, Integer xMsLeaseDuration, final
  ServiceCallback<Void> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(leasePathWithServiceResponseAsync(xMsLeaseAction, xMsLeaseId, filesystem, path, xMsLeaseDuration), serviceCallback);
  }

  /**
   * Lease Path.
   * Create and manage a lease to restrict write and delete access to the path. This operation supports conditional HTTP requests.  For more information, see
   * [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param xMsLeaseAction There are three lease actions: "acquire", "renew", and "release".  Use "acquire" and specify the "x-ms-lease-duration" to create a
   *                      new file lease.  Use "renew" and specify the "leaseId" to renew an existing lease.  Use "release" and specify the "leaseId" to
   *                      release a lease.
   * @param xMsLeaseId The lease ID must be specified.  For the acquire action, this is the proposed ID for the new lease.  For the renew and release
   *                   actions, this must match the current lease ID.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param xMsLeaseDuration The lease duration is required to acquire a lease, and specifies the duration of the lease in seconds.  The lease duration must
   *                         be between 15 and 60 seconds.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> leasePathAsync(String xMsLeaseAction, String xMsLeaseId, String filesystem, String path, Integer xMsLeaseDuration) {
    return leasePathWithServiceResponseAsync(xMsLeaseAction, xMsLeaseId, filesystem, path, xMsLeaseDuration).map(new Func1<ServiceResponseWithHeaders<Void,
        LeasePathHeaders>, Void>() {
      @Override
      public Void call(ServiceResponseWithHeaders<Void, LeasePathHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Lease Path.
   * Create and manage a lease to restrict write and delete access to the path. This operation supports conditional HTTP requests.  For more information, see
   * [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param xMsLeaseAction There are three lease actions: "acquire", "renew", and "release".  Use "acquire" and specify the "x-ms-lease-duration" to create a
   *                      new file lease.  Use "renew" and specify the "leaseId" to renew an existing lease.  Use "release" and specify the "leaseId" to
   *                      release a lease.
   * @param xMsLeaseId The lease ID must be specified.  For the acquire action, this is the proposed ID for the new lease.  For the renew and release
   *                   actions, this must match the current lease ID.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param xMsLeaseDuration The lease duration is required to acquire a lease, and specifies the duration of the lease in seconds.  The lease duration must
   *                         be between 15 and 60 seconds.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, LeasePathHeaders>> leasePathWithServiceResponseAsync(String xMsLeaseAction, String xMsLeaseId, String
      filesystem, String path, Integer xMsLeaseDuration) {
    if (xMsLeaseAction == null) {
      throw new IllegalArgumentException("Parameter xMsLeaseAction is required and cannot be null.");
    }
    if (xMsLeaseId == null) {
      throw new IllegalArgumentException("Parameter xMsLeaseId is required and cannot be null.");
    }
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (path == null) {
      throw new IllegalArgumentException("Parameter path is required and cannot be null.");
    }
    return service.leasePath(filesystem, path, xMsLeaseAction, xMsLeaseDuration, xMsLeaseId, this.timeout(), this.authorization(), this.dateProperty(), this
        .xMsVersion(), this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, LeasePathHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, LeasePathHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<Void, LeasePathHeaders> clientResponse = leasePathDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  private ServiceResponseWithHeaders<Void, LeasePathHeaders> leasePathDelegate(Response<ResponseBody> response) throws ErrorSchemaException, IOException,
      IllegalArgumentException {
    return this.restClient().responseBuilderFactory().<Void, ErrorSchemaException>newInstance(this.serializerAdapter())
        .register(200, new TypeToken<Void>() {
        }.getType())
        .register(201, new TypeToken<Void>() {
        }.getType())
        .registerError(ErrorSchemaException.class)
        .buildWithHeaders(response, LeasePathHeaders.class);
  }

  /**
   * Read File.
   * Read the contents of a file.  For read operations, range requests are supported. This operation supports conditional HTTP requests.  For more
   * information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   * @return the InputStream object if successful.
   */
  public InputStream readPath(String filesystem, String path) {
    return readPathWithServiceResponseAsync(filesystem, path).toBlocking().single().body();
  }

  /**
   * Read File.
   * Read the contents of a file.  For read operations, range requests are supported. This operation supports conditional HTTP requests.  For more
   * information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<InputStream> readPathAsync(String filesystem, String path, final ServiceCallback<InputStream> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(readPathWithServiceResponseAsync(filesystem, path), serviceCallback);
  }

  /**
   * Read File.
   * Read the contents of a file.  For read operations, range requests are supported. This operation supports conditional HTTP requests.  For more
   * information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the observable to the InputStream object
   */
  public Observable<InputStream> readPathAsync(String filesystem, String path) {
    return readPathWithServiceResponseAsync(filesystem, path).map(new Func1<ServiceResponseWithHeaders<InputStream, ReadPathHeaders>, InputStream>() {
      @Override
      public InputStream call(ServiceResponseWithHeaders<InputStream, ReadPathHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Read File.
   * Read the contents of a file.  For read operations, range requests are supported. This operation supports conditional HTTP requests.  For more
   * information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft
   * .com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the observable to the InputStream object
   */
  public Observable<ServiceResponseWithHeaders<InputStream, ReadPathHeaders>> readPathWithServiceResponseAsync(String filesystem, String path) {
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (path == null) {
      throw new IllegalArgumentException("Parameter path is required and cannot be null.");
    }
    return service.readPath(filesystem, path, this.timeout(), this.authorization(), this.dateProperty(), this.xMsVersion(), this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<InputStream, ReadPathHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<InputStream, ReadPathHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<InputStream, ReadPathHeaders> clientResponse = readPathDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  private ServiceResponseWithHeaders<InputStream, ReadPathHeaders> readPathDelegate(Response<ResponseBody> response) throws ErrorSchemaException,
      IOException, IllegalArgumentException {
    return this.restClient().responseBuilderFactory().<InputStream, ErrorSchemaException>newInstance(this.serializerAdapter())
        .register(200, new TypeToken<InputStream>() {
        }.getType())
        .register(206, new TypeToken<InputStream>() {
        }.getType())
        .registerError(ErrorSchemaException.class)
        .buildWithHeaders(response, ReadPathHeaders.class);
  }

  /**
   * Get File Properties | Get Directory Properties.
   * Get the properties for a file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional
   * Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void getPathProperties(String filesystem, String path) {
    getPathPropertiesWithServiceResponseAsync(filesystem, path).toBlocking().single().body();
  }

  /**
   * Get File Properties | Get Directory Properties.
   * Get the properties for a file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional
   * Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> getPathPropertiesAsync(String filesystem, String path, final ServiceCallback<Void> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(getPathPropertiesWithServiceResponseAsync(filesystem, path), serviceCallback);
  }

  /**
   * Get File Properties | Get Directory Properties.
   * Get the properties for a file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional
   * Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> getPathPropertiesAsync(String filesystem, String path) {
    return getPathPropertiesWithServiceResponseAsync(filesystem, path).map(new Func1<ServiceResponseWithHeaders<Void, GetPathPropertiesHeaders>, Void>() {
      @Override
      public Void call(ServiceResponseWithHeaders<Void, GetPathPropertiesHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Get File Properties | Get Directory Properties.
   * Get the properties for a file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional
   * Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, GetPathPropertiesHeaders>> getPathPropertiesWithServiceResponseAsync(String filesystem, String path) {
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (path == null) {
      throw new IllegalArgumentException("Parameter path is required and cannot be null.");
    }
    return service.getPathProperties(filesystem, path, this.timeout(), this.authorization(), this.dateProperty(), this.xMsVersion(), this.xMsClientRequestId())
        .flatMap(new Func1<Response<Void>, Observable<ServiceResponseWithHeaders<Void, GetPathPropertiesHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, GetPathPropertiesHeaders>> call(Response<Void> response) {
            try {
              ServiceResponseWithHeaders<Void, GetPathPropertiesHeaders> clientResponse = getPathPropertiesDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  private ServiceResponseWithHeaders<Void, GetPathPropertiesHeaders> getPathPropertiesDelegate(Response<Void> response) throws ErrorSchemaException,
      IOException, IllegalArgumentException {
    return this.restClient().responseBuilderFactory().<Void, ErrorSchemaException>newInstance(this.serializerAdapter())
        .register(200, new TypeToken<Void>() {
        }.getType())
        .registerError(ErrorSchemaException.class)
        .buildEmptyWithHeaders(response, GetPathPropertiesHeaders.class);
  }

  /**
   * Delete File | Delete Directory.
   * Delete the file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob
   * Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void deletePath(String resource, String filesystem, String path) {
    deletePathWithServiceResponseAsync(resource, filesystem, path).toBlocking().single().body();
  }

  /**
   * Delete File | Delete Directory.
   * Delete the file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob
   * Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> deletePathAsync(String resource, String filesystem, String path, final ServiceCallback<Void> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(deletePathWithServiceResponseAsync(resource, filesystem, path), serviceCallback);
  }

  /**
   * Delete File | Delete Directory.
   * Delete the file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob
   * Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> deletePathAsync(String resource, String filesystem, String path) {
    return deletePathWithServiceResponseAsync(resource, filesystem, path).map(new Func1<ServiceResponseWithHeaders<Void, DeletePathHeaders>, Void>() {
      @Override
      public Void call(ServiceResponseWithHeaders<Void, DeletePathHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Delete File | Delete Directory.
   * Delete the file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob
   * Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, DeletePathHeaders>> deletePathWithServiceResponseAsync(String resource, String filesystem, String path) {
    if (resource == null) {
      throw new IllegalArgumentException("Parameter resource is required and cannot be null.");
    }
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (path == null) {
      throw new IllegalArgumentException("Parameter path is required and cannot be null.");
    }
    final Boolean recursive = null;
    final String xMsLeaseId = null;
    return service.deletePath(filesystem, path, recursive, resource, xMsLeaseId, this.timeout(), this.authorization(), this.dateProperty(), this.xMsVersion()
        , this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, DeletePathHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, DeletePathHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<Void, DeletePathHeaders> clientResponse = deletePathDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  /**
   * Delete File | Delete Directory.
   * Delete the file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob
   * Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param recursive Required and valid only when the resource is a directory.  If "true", all paths beneath the directory will be deleted. If "false" and
   *                  the directory is non-empty, an error occurs.
   * @param xMsLeaseId The lease ID must be specified if there is an active lease.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @throws ErrorSchemaException thrown if the request is rejected by server
   * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
   */
  public void deletePath(String resource, String filesystem, String path, Boolean recursive, String xMsLeaseId) {
    deletePathWithServiceResponseAsync(resource, filesystem, path, recursive, xMsLeaseId).toBlocking().single().body();
  }

  /**
   * Delete File | Delete Directory.
   * Delete the file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob
   * Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param recursive Required and valid only when the resource is a directory.  If "true", all paths beneath the directory will be deleted. If "false" and
   *                  the directory is non-empty, an error occurs.
   * @param xMsLeaseId The lease ID must be specified if there is an active lease.
   * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceFuture} object
   */
  public ServiceFuture<Void> deletePathAsync(String resource, String filesystem, String path, Boolean recursive, String xMsLeaseId, final
  ServiceCallback<Void> serviceCallback) {
    return ServiceFuture.fromHeaderResponse(deletePathWithServiceResponseAsync(resource, filesystem, path, recursive, xMsLeaseId), serviceCallback);
  }

  /**
   * Delete File | Delete Directory.
   * Delete the file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob
   * Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param recursive Required and valid only when the resource is a directory.  If "true", all paths beneath the directory will be deleted. If "false" and
   *                  the directory is non-empty, an error occurs.
   * @param xMsLeaseId The lease ID must be specified if there is an active lease.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<Void> deletePathAsync(String resource, String filesystem, String path, Boolean recursive, String xMsLeaseId) {
    return deletePathWithServiceResponseAsync(resource, filesystem, path, recursive, xMsLeaseId).map(new Func1<ServiceResponseWithHeaders<Void,
        DeletePathHeaders>, Void>() {
      @Override
      public Void call(ServiceResponseWithHeaders<Void, DeletePathHeaders> response) {
        return response.body();
      }
    });
  }

  /**
   * Delete File | Delete Directory.
   * Delete the file or directory. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob
   * Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   *
   * @param resource The value must be "file" or "directory" to indicate the resource type.
   * @param filesystem The filesystem identifier.
   * @param path The file or directory path.
   * @param recursive Required and valid only when the resource is a directory.  If "true", all paths beneath the directory will be deleted. If "false" and
   *                  the directory is non-empty, an error occurs.
   * @param xMsLeaseId The lease ID must be specified if there is an active lease.
   * @throws IllegalArgumentException thrown if parameters fail the validation
   * @return the {@link ServiceResponseWithHeaders} object if successful.
   */
  public Observable<ServiceResponseWithHeaders<Void, DeletePathHeaders>> deletePathWithServiceResponseAsync(String resource, String filesystem, String path,
      Boolean recursive, String xMsLeaseId) {
    if (resource == null) {
      throw new IllegalArgumentException("Parameter resource is required and cannot be null.");
    }
    if (filesystem == null) {
      throw new IllegalArgumentException("Parameter filesystem is required and cannot be null.");
    }
    if (path == null) {
      throw new IllegalArgumentException("Parameter path is required and cannot be null.");
    }
    return service.deletePath(filesystem, path, recursive, resource, xMsLeaseId, this.timeout(), this.authorization(), this.dateProperty(), this.xMsVersion()
        , this.xMsClientRequestId())
        .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, DeletePathHeaders>>>() {
          @Override
          public Observable<ServiceResponseWithHeaders<Void, DeletePathHeaders>> call(Response<ResponseBody> response) {
            try {
              ServiceResponseWithHeaders<Void, DeletePathHeaders> clientResponse = deletePathDelegate(response);
              return Observable.just(clientResponse);
            } catch (Throwable t) {
              return Observable.error(t);
            }
          }
        });
  }

  private ServiceResponseWithHeaders<Void, DeletePathHeaders> deletePathDelegate(Response<ResponseBody> response) throws ErrorSchemaException, IOException,
      IllegalArgumentException {
    return this.restClient().responseBuilderFactory().<Void, ErrorSchemaException>newInstance(this.serializerAdapter())
        .register(200, new TypeToken<Void>() {
        }.getType())
        .registerError(ErrorSchemaException.class)
        .buildWithHeaders(response, DeletePathHeaders.class);
  }

}
